// Default empty project template
#include "WordsPlus.hpp"
#include "wordsearch.h"
#include "ActiveFrame.h"
#include <string>

#include <bb/cascades/Application>
#include <bb/cascades/QmlDocument>
#include <bb/cascades/AbstractPane>
#include <bb/cascades/TabbedPane>
#include <bb/cascades/NavigationPane>
#include <bb/cascades/Container>
#include <bb/cascades/Color>
#include <bb/cascades/Page>
#include <bb/cascades/Label>
#include <bb/cascades/SystemDefaults>
#include <bb/cascades/StackLayout>
#include <bb/cascades/StackLayoutProperties>
#include <bb/cascades/AbsoluteLayout>
#include <bb/cascades/AbsoluteLayoutProperties>
#include <bb/system/SystemToast>

#define NORMAL		1
#define SELECTED	2
#define HIGHLIGHT	3
#define WORDSFOUND "settingsWordsFound"


#include <bps/bps.h>
#include <bps/navigator.h>
#include <bps/dialog.h>

#include <scoreloop/scoreloopcore.h>
/*-------------------------------------------------------------------------------------*
 * Defines
 *-------------------------------------------------------------------------------------*/

/* These are the game id and game secret from the SL Demo TNG game - use your credentials (and SLAward.bundle) instead */
#define GAME_ID         "acb55270-30e0-47b2-9d27-564f7bb163a6"
#define GAME_SECRET     "lQh1gNf3W9LJ53kAklF5x/YOLx1JJbSwsAXI7OBxWegNoYWaT/GRNA=="
#define GAME_VERSION	"1.0"
#define GAME_CURRENCY   "GRL"
#define GAME_LANGUAGE   "en"
#define AN_AWARD_ID     "com.scoreloop.demo.smiley"

/* Some simple logging */
#define LOG(fmt, args...)   do { fprintf(stdout, "[Scoreloop Sample] " fmt "\n", ##args); fflush(stdout); } while (0);

/*-------------------------------------------------------------------------------------*
 * Types
 *-------------------------------------------------------------------------------------*/

/* Your application will probably have some top level representation like this. */
typedef struct AppData_tag {
    SC_Client_h client;
    SC_Score_h score;
    SC_UserController_h userController;
    SC_ScoreController_h scoreController;
    SC_ScoresController_h scoresController;
    SC_LocalAchievementsController_h achievementsController;
    SC_ChallengeController_h challengeController;
    SC_ChallengesController_h challengesController;
    dialog_instance_t dialog;
} AppData_t;

/*-------------------------------------------------------------------------------------*
 * Forward Declarations
 *-------------------------------------------------------------------------------------*/

static void RequestUser(AppData_t *app);
static void RequestUserCompletionCallback(void *userData, SC_Error_t completionStatus);

static void SubmitScore(AppData_t *app, double result, unsigned int mode);
static void SubmitScoreCompletionCallback(void *userData, SC_Error_t completionStatus);

static void LoadLeaderboard(AppData_t *app, SC_Score_h score, SC_ScoresSearchList_t searchList, unsigned int count);
static void LoadLeaderboardCompletionCallback(void *userData, SC_Error_t completionStatus);

static void AchieveAward(AppData_t *app, const char *awardIdentifier);
static void AchieveAwardCompletionCallback(void *userData, SC_Error_t completionStatus);

static void LoadAchievements(AppData_t *app);
static void LoadAchievementsCompletionCallback(void *userData, SC_Error_t completionStatus);

static void CreateChallenge(AppData_t *app, SC_Money_h stake, double result, unsigned int mode);
static void CreateChallengeCompletionCallback(void *userData, SC_Error_t completionStatus);

static void LoadChallenges(AppData_t *app);
static void LoadChallengesCompletionCallback(void *userData, SC_Error_t completionStatus);

static void AcceptChallenge(AppData_t *app, SC_Challenge_h challenge);
static void AcceptChallengeCompletionCallback(void *userData, SC_Error_t completionStatus);

static void SubmitChallenge(AppData_t *app, SC_Challenge_h challenge, double result, unsigned int mode);
static void SubmitChallengeCompletionCallback(void *userData, SC_Error_t completionStatus);

static void DisplayDialog(AppData_t *app, const char* title, const char* message);
static void InformUser(AppData_t *app, const char* title, const char* message);
static void HandleError(AppData_t *app, SC_Error_t error);

static double GetScoreResult(AppData_t *app);
static SC_Money_h GetStake(AppData_t *app);


using namespace bb::cascades;
using namespace bb::system;

WordsPlus::WordsPlus(bb::cascades::Application *appqml) : QObject(appqml) {

	settings = new GameSettings();

	//set default values
	setCategory("weather");
	deltaX = 0.0;
	deltaY = 0.0;
	multiple = 1;
	length = 0;
	upperbound = 100;
	lowerbound = 0;
	position = 0;
	tileSize = 50;
	timeSec = 0;
	stopWatch = NULL;
	numberOfWordsFound = 0;


	/* SCORELOOP */

		AppData_t app;
	    SC_InitData_t initData;
	    SC_Error_t rc;
	    char versionBuffer[0x100]; /* Thats 256 bytes */

	    LOG("Starting Scoreloop Sample...")

	    /* Initialize the BPS event system */
	    bps_initialize();
	    bps_set_verbosity(0); /* Set to 1 or 2 for more output if you like */
	    navigator_request_events(0);
	    dialog_request_events(0);

	    memset(&app, 0, sizeof(AppData_t));

	    /* Initialize the Scoreloop platform dependent SC_InitData_t structure to default values. */
	    SC_InitData_Init(&initData);

	    /* What version of the Scoreloop library do we use? */
	    if (SC_GetVersionInfo(&initData, versionBuffer, sizeof(versionBuffer))) {
	        LOG("Version-Info: %s", versionBuffer);
	    }

	    /* Now, create the Scoreloop Client with the initialized SC_InitData_t structure
	     * as well as the game-id and game-secret as found on the developer portal.
	     */
	    rc = SC_Client_New(&app.client, &initData, GAME_ID, GAME_SECRET, GAME_VERSION, GAME_CURRENCY, GAME_LANGUAGE);
	    if (rc != SC_OK) {
	        HandleError(&app, rc);
	    }
	    else {
	        InformUser(&app, "Note", "Scoreloop Sample started...");

	        /* Request the user here just for demonstration purposes */
	        RequestUser(&app);
	    }

	    LOG("Done with RequestUser");

//	    /* Now start the BPS runloop */
//	    while (true) {
//
//	        /* Get next BPS event */
//	        bps_event_t *event;
//	        bps_get_event(&event, -1);
//
//
//	        /* Scoreloop event handling  */
//	        if (bps_event_get_domain(event) == SC_GetBPSEventDomain(&initData)) {
//	            SC_HandleBPSEvent(&initData, event);
//	        }
//	        /* Dialog and Navigator event handling */
//	        else if (bps_event_get_domain(event) == navigator_get_domain()) {
//	            if (bps_event_get_code(event) == NAVIGATOR_EXIT) {
//	                break;
//	            }
//	        }
//	        else if (bps_event_get_domain(event) == dialog_get_domain()) {
//	            dialog_destroy(dialog_event_get_dialog_instance(event));
//	    		app.dialog = 0;
//	        }
//	        /* Add more BPS event handling here... */
//	    }
//
//	    /* Cleanup the Scoreloop client */
//	    SC_Client_Release(app.client);
//
//	    /* Shutdown BPS */
//	    bps_shutdown();
//
//	    LOG("Done with Scoreloop Sample");
//	    /* SCORELOOP */


	mQmlDocument = QmlDocument::create("asset:///main.qml");
	mQmlDocument->setParent(this);
	mQmlDocument->setContextProperty("wordsPlus", this);

	if (!mQmlDocument->hasErrors()) {

		// The application navigationPane is created from QML.
		tabs = mQmlDocument->createRootObject<TabbedPane>();

		if (tabs) {

		    // Create the cover now. When application in moved to a background it's too late
			// to create some UI controls or send asynch. requests. Remember ActiveFrame is refreshed every 30sec.
			// Using DataModel in ActiveFrame isn't good idea too.
			// Provider creates the CustomControls once they are needed.
			appqml->setCover(new ActiveFrame());

			//possible connecting to a function here so on thumbnail - stop timer
			//QObject::connect(Application::instance(), SIGNAL(thumbnail()), this, SLOT(onThumbnail()));

			intializePlayArea(); //check spelling :)
			stopTimer();

			// Set the main application scene to NavigationPane.
			Application::instance()->setScene(tabs);
		}
	}
}


void WordsPlus::intializePlayArea() {

	mPlayAreaContainer = tabs->findChild<Container*>("playAreaContainer");
	mPlayAreaContainer->removeAll();

	Container *mWordsToFindContainer = tabs->findChild<Container*>("wordsToFind");
	mWordsToFindContainer->removeAll();

	Container* pContainer = new Container();
	AbsoluteLayout *pAbsoluteLayout = new AbsoluteLayout();
	pContainer->setLayout(pAbsoluteLayout);

	TextStyle subTitleWhite = SystemDefaults::TextStyles::smallText();
	subTitleWhite.setColor(Color::fromARGB(0xfffafafa));


	// As long as nothing is broken, we continue.
	if (mPlayAreaContainer) {

		std::string cat = getCategory().toStdString();
		cat.append(".txt");
//		printf(cat.c_str());
//		fflush(stdout);
		char** letter = createNewPuzzle((char*) cat.c_str());
		char** puzzleWords = returnPuzzleWords();

		QString listOfWords;
		numberOfWords = returnNumberOfPuzzleWords();

		printf("WordsPlus\n");
		printf("Number Of Words: ");
		printf("%i", numberOfWords);
		for (int i = 0; i < numberOfWords; i++) {
			listOfWords.append(puzzleWords[i]);
			listOfWords.append(' ');

			//get word, create label and add to wordsToFind container
			QString labelText = puzzleWords[i];
			Label *wordLabel = new Label();
			wordLabel->textStyle()->setBase(subTitleWhite);
			wordLabel->setObjectName(labelText);
			wordLabel->setText(labelText);

			printf("\n");
			printf("%s", labelText.toStdString().c_str());
			fflush(stdout);

			//always give them x space and then if total is more than 720
			//update positionY (new line)

			if(i <= 3) {
				AbsoluteLayoutProperties* pProperties = AbsoluteLayoutProperties::create();
				pProperties->setPositionX(180.0 * i);
				pProperties->setPositionY(0.0);
				wordLabel->setLayoutProperties(pProperties);
				pContainer->add(wordLabel);
			}
			if(i >= 4 && i <= 7) {
				AbsoluteLayoutProperties* pProperties = AbsoluteLayoutProperties::create();
				pProperties->setPositionX(180.0 * (i-4));
				pProperties->setPositionY(30.0);
				wordLabel->setLayoutProperties(pProperties);
				pContainer->add(wordLabel);
			}
			if(i >= 8) {
				AbsoluteLayoutProperties* pProperties = AbsoluteLayoutProperties::create();
				pProperties->setPositionX(180.0 * (i-8));
				pProperties->setPositionY(60.0);
				wordLabel->setLayoutProperties(pProperties);
				pContainer->add(wordLabel);
			}

			mWordsToFindContainer->add(pContainer);
		}

		setPuzzleWords(listOfWords);

		mNumTiles = 10; // Calculate the size of the tiles
		mWantedSize = mPlayAreaContainer->preferredWidth() / mNumTiles;

		// Iterate through all the tiles.
		for (int i = 0; i < mNumTiles; i++) {
			Container* columnContainer = new Container();

			for (int ii = 0; ii < mNumTiles; ii++) {
				ImageView *imageView =
						ImageView::create().bottomMargin(0).topMargin(0).leftMargin(
								0).rightMargin(0);
				imageView->setPreferredSize(mWantedSize, mWantedSize);

				QString imageSource =
						QString("asset:///images/letters/%1.png").arg(
								QString(letter[i][ii]).toLower());
				imageView->setImage(Image(imageSource));

				// We are connecting all our tiles to the same slot, we can later identify them by sender().
				connect(imageView, SIGNAL(touch(bb::cascades::TouchEvent *)),
						this, SLOT(onTileTouch(bb::cascades::TouchEvent *)));

				// Keep track of the ImageView.
				mPlayField[i][ii] = imageView;
				mPlayField[i][ii]->setObjectName(QString(letter[i][ii]).toLower());
				columnContainer->add(imageView);
			}

			mPlayAreaContainer->add(columnContainer);
		} // for loop

		//Call timer class - Depends on what challenge (regular or beat-the-clock type thing)
		initTimer();
		resetTimer();
		numberOfWordsFound = 0;

	} // set up mPlayAreaContainer
}


void WordsPlus::onTileTouch(bb::cascades::TouchEvent *event) {

	if (event->isDown()) {
		// Find who sent it.
		ImageView* senderImage = dynamic_cast<ImageView*>(sender());
		if (senderImage != NULL) {

			multiple = 1;
			//get initial position of finger touch
			initX = event->windowX();
			initY = event->windowY();

			// If that container is real, we iterate through all the tiles.
			for (int i = 0; i < mNumTiles; i++) {
				for (int ii = 0; ii < mNumTiles; ii++) {

					if (mPlayField[i][ii] == senderImage) {

						// Get array position
						if( i == 0 ) { position = ii; }
						if( i > 0 ) { position = i*10 + ii; }
						tileNumbers.append(position);
						HighlightSelectedTile(position, HIGHLIGHT);
					}
				} // Inner loop
			} // Outer loop
		} // if statement
	} // isDown

	if (event->isMove()) {

		deltaX = event->windowX() - initX;
		deltaY = event->windowY() - initY;

//		printf("(%i , %i) ", (int) deltaX, (int) deltaY);
//		fflush(stdout);

		//Y direction only
		if( deltaX >= -25 && deltaX <= 25 ){
			length = (int) deltaY;
			//deltaY increases (+ve) when finger moves top to bottom
			if(length / 60 == multiple && length > 0) {
				position += 1;
				if( position < upperbound) {
					HighlightSelectedTile(position, HIGHLIGHT);
					tileNumbers.append(position);
					multiple++;
				}
			}
			//deltaY decreases (-ve) when finger moves bottom to top
			if(length / 60 == -multiple && length < 0) {
				position -= 1;
				if( position > lowerbound) {
					HighlightSelectedTile(position, HIGHLIGHT);
					tileNumbers.append(position);
					multiple++;
				}
			}
		}
		else if( deltaY >= -25 && deltaY <= 25 ){
			length = (int) deltaX;
			//deltaX increases (+ve) when finger moves left to right
			if(length / 60 == multiple && length > 0) {
				position += 10;
				if( position < upperbound) {
					HighlightSelectedTile(position, HIGHLIGHT);
					tileNumbers.append(position);
					multiple++;
				}
			}
			//deltaX decreases (-ve) when finger moves right to left
			if(length / 60 == -multiple && length < 0) {
				position -= 10;
				if( position > lowerbound) {
					HighlightSelectedTile(position, HIGHLIGHT);
					tileNumbers.append(position);
					multiple++;
				}
			}
		}
		else if( deltaX > 25 ) { //east
			if( deltaY > 25) { // diagonal South East
				length = (int) deltaY;
				if(length / 60 == multiple) {
					position +=10; //x
					position +=1; //y
					if (position < upperbound) {
						HighlightSelectedTile(position, HIGHLIGHT);
						tileNumbers.append(position);
						multiple++;
					}
				}
			}
			if( deltaY < -25) { // diagonal North East
				length = (int) deltaY;
				if(length / 60 == -multiple) {
					position +=10; //x
					position -=1; //y
					if (position < upperbound) {
						HighlightSelectedTile(position, HIGHLIGHT);
						tileNumbers.append(position);
						multiple++;
					}
				}
			}
		}
		else if( deltaX < -25 ) { // west
			if( deltaY > 25) { // diagonal South West
				length = (int) deltaY;
				if(length / 60 == multiple) {
					position -=10; //x
					position +=1; //y
					if (position > lowerbound) {
						HighlightSelectedTile(position, HIGHLIGHT);
						tileNumbers.append(position);
						multiple++;
					}
				}
			}
			if( deltaY < -25) { // diagonal North West
				length = (int) deltaY;
				if(length / 60 == -multiple) {
					position -=10; //x
					position -=1; //y
					if (position > lowerbound) {
						HighlightSelectedTile(position, HIGHLIGHT);
						tileNumbers.append(position);
						multiple++;
					}
				}
			}
		}

	} // isMove

	if (event->isUp()) {
		position = 0;
		multiple = 1;
		WordCompleted(tileNumbers);
		tileNumbers.clear();
	} // isUp

}

void WordsPlus::HighlightSelectedTile(int pos, int stateOfLetter) {

	int i; int ii;
	QString imageSource;

	if( pos <= 9) { i = 0; ii = pos; }
	if( pos >= 10) {
		i = pos / 10;
		ii = pos % 10;
	}

	// Get the object name (actually the image name which is easy to identify).
	QVariant v = mPlayField[i][ii]->imageSource();

	if (v.canConvert<QString>()) {
	  QString objURL = v.value<QString>();
	  QStringList imageSrc = objURL.split("/");
	  int index = imageSrc.size() - 1; // size gives count not last index

	  switch(stateOfLetter) {
		  case NORMAL:
			  imageSource = QString("asset:///images/letters/%1").arg(imageSrc[index]);
			  break;
		  case SELECTED:
			  imageSource = QString("asset:///images/letters/selected/%1").arg(imageSrc[index]);
			  mPlayField[i][ii]->setObjectName("selected");
			  break;
		  case HIGHLIGHT:
			  imageSource = QString("asset:///images/letters/highlight/%1").arg(imageSrc[index]);
			  break;
	  }

	  mPlayField[i][ii]->setImage(Image(imageSource));
	}

}

void WordsPlus::WordCompleted(QList<int> listOfNumbers) {

	int i; int ii;
	QString selectedWord;
	QStringList puzzleWords;

	// get array of puzzle words
	puzzleWords = getPuzzleWords().split(" ");

	// get corresponding letters and make word
	for(int j = 0; j < listOfNumbers.size(); j++) {
		int pos = listOfNumbers.at(j);

		if( pos <= 9) { i = 0; ii = pos; }
		if( pos >= 10) {
			i = pos / 10;
			ii = pos % 10;
		}

		QVariant v = mPlayField[i][ii]->imageSource();

		if (v.canConvert<QString>()) {
			QString objURL = v.value<QString>();
			QStringList imageSrc = objURL.split("/");
			int index = imageSrc.size() - 1; // size gives count not last index
			QString letter = imageSrc[index].split(".")[0];
			selectedWord.append(letter.toUpper()); // append letters to make word
		}
	}

	if(puzzleWords.indexOf(selectedWord) >= 0) { //word found in puzzle words
		for(int j = 0; j < listOfNumbers.size(); j++) {
			int pos = listOfNumbers.at(j);
			HighlightSelectedTile(pos, SELECTED);
		}

		numberOfWordsFound++;
		CrossOutPuzzleWord(selectedWord);

		// save off total words found
		bool ok;
		int found = settings->getValueFor(WORDSFOUND, "0").toInt(&ok, 10);
		if(ok) {
			found++;
			settings->saveValueFor(WORDSFOUND, QString::number(found));
			emit totalWordsFoundChanged();
		}

		if( numberOfWordsFound == numberOfWords) {
			showToast("PUZZLE COMPLETED!"); // add icon url to pass to function
			intializePlayArea(); // create a new puzzle
		}
	}
	else {
		for(int j = 0; j < listOfNumbers.size(); j++) { //word not found in puzzle words
			int pos = listOfNumbers.at(j);

			if( pos <= 9) { i = 0; ii = pos; }
			if( pos >= 10) {
				i = pos / 10;
				ii = pos % 10;
			}

			QVariant v = mPlayField[i][ii]->objectName();

			if (v.canConvert<QString>()) {
			  QString objName = v.value<QString>(); // letter of word completed

			  if(!objName.contains("selected", Qt::CaseInsensitive)) { // not part of another word
				  HighlightSelectedTile(pos, NORMAL);
			  }
			  else{
				  HighlightSelectedTile(pos, SELECTED);
			  }
			}
		}
	}

}

void WordsPlus::CrossOutPuzzleWord(QString wordFound) {

	Label *mWordFound = tabs->findChild<Label*>(wordFound);

	TextStyle subTitleSelected = SystemDefaults::TextStyles::smallText();
	subTitleSelected.setColor(Color::fromARGB(0xff00629C));

	mWordFound->textStyle()->setBase(subTitleSelected);
}

void WordsPlus::showToast(QString msg) {
    SystemToast *toast = new SystemToast(this);
    toast->setBody(msg);
    toast->setPosition(SystemUiPosition::TopCenter);
    toast->show();
}

void WordsPlus::onTick()
{
	timeSec++;
	timeKeeper = QDateTime::fromTime_t(timeSec);

	m_strTime = timeKeeper.toString("mm':'ss");
//	printf("(%s)", m_strTime.toStdString().c_str());
//	fflush(stdout);

	emit timeChanged();
}

void WordsPlus::initTimer() {

	if(stopWatch == NULL) {
		stopWatch = new Timer();
		connect(stopWatch, SIGNAL(timeout()), this, SLOT(onTick()));
		stopWatch->setInterval(1000);
	}
}

void WordsPlus::startTimer(){

	if(stopWatch == NULL) {
		//do nothing
	}
	else{
		stopWatch->start();
	}
}

void WordsPlus::stopTimer() {

	if(stopWatch == NULL) {
		//do nothing
	}
	else {
		stopWatch->stop();
	}
}

void WordsPlus::resetTimer() {

	if(stopWatch != NULL) {
		stopWatch->stop();
		timeSec = 0;
		stopWatch->start();
	}
}

QString WordsPlus::getCategory() {
	return m_strCategory;
}

void WordsPlus::setCategory(const QString cat) {
	m_strCategory = cat;
	emit categoryChanged(m_strCategory);
}

QString WordsPlus::getPuzzleWords() {
	return m_strPuzzleWords;
}

void WordsPlus::setPuzzleWords(const QString words) {
	m_strPuzzleWords = words;
	emit puzzleWordsChanged(m_strPuzzleWords);
}

QString WordsPlus::getTime(){
	return m_strTime;
}

QString WordsPlus::getTotalWordsFound() {
	return settings->getValueFor(WORDSFOUND, "0");
}


/*-------------------------------------------------------------------------------------*
 * Functions
 *-------------------------------------------------------------------------------------*/

static void RequestUser(AppData_t *app)
{
    /* Create a UserController */
    SC_Error_t rc = SC_Client_CreateUserController(app->client, &app->userController, RequestUserCompletionCallback, app);
    if (rc != SC_OK) {
        HandleError(app, rc);
        return;
    }

    /* Make the asynchronous request */
    rc = SC_UserController_LoadUser(app->userController);
    if (rc != SC_OK) {
        SC_UserController_Release(app->userController);
        HandleError(app, rc);
        return;
    }
    LOG("Requesting User...");
}

static void RequestUserCompletionCallback(void *userData, SC_Error_t completionStatus)
{
    /* Get the application from userData argument */
    AppData_t *app = (AppData_t *) userData;
    char buf[0x100];

    /* Check completion status */
    if (completionStatus != SC_OK) {
        SC_UserController_Release(app->userController); /* Cleanup Controller */
        HandleError(app, completionStatus);
        return;
    }
    LOG("Done requesting User");

    /* Get the session from the client. */
    SC_Session_h session = SC_Client_GetSession(app->client);

    /* Get the session user from the session. */
    SC_User_h user = SC_Session_GetUser(session);

    /* Write out some user data */
    SC_String_h login = SC_User_GetLogin(user);
    LOG("  User's login: %s", login ? SC_String_GetData(login) : "<unknown>");
    SC_String_h email = SC_User_GetEmail(user);
    LOG("  User's email: %s", email ? SC_String_GetData(email) : "<unknown>");

    /* Also show login in dialog for convenience */
    snprintf(buf, sizeof(buf), "Scoreloop login name: %s", login ? SC_String_GetData(login) : "<unknown>");
    InformUser(app, "Note", buf);

    /* We don't need the UserController anymore, so release it */
    SC_UserController_Release(app->userController);

    /* Submit a random score here just for demonstration purposes */
    SubmitScore(app, GetScoreResult(app), 0);
}

static void SubmitScore(AppData_t *app, double result, unsigned int mode)
{
    /* Create a ScoreController */
    SC_Error_t rc = SC_Client_CreateScoreController(app->client, &app->scoreController, SubmitScoreCompletionCallback, app);
    if (rc != SC_OK) {
        HandleError(app, rc);
        return;
    }

    /* Create and configure the score */
    rc = SC_Client_CreateScore(app->client, &app->score);
    if (rc != SC_OK) {
        SC_ScoreController_Release(app->scoreController); /* Cleanup Controller */
        HandleError(app, rc);
        return;
    }
    SC_Score_SetResult(app->score, result);
    SC_Score_SetMode(app->score, mode);

    /* Submit the score */
    rc = SC_ScoreController_SubmitScore(app->scoreController, app->score);
    if (rc != SC_OK) {
        SC_ScoreController_Release(app->scoreController); /* Cleanup Controller */
        SC_Score_Release(app->score); /* Cleanup Score */
        HandleError(app, rc);
        return;
    }
    LOG("Submitting Score...");
}

static void SubmitScoreCompletionCallback(void *userData, SC_Error_t completionStatus)
{
    /* Get the application from userData argument */
    AppData_t *app = (AppData_t *) userData;

    /* Check completion status */
    if (completionStatus != SC_OK) {
        SC_ScoreController_Release(app->scoreController); /* Cleanup Controller */
        SC_Score_Release(app->score); /* Cleanup Score */
        HandleError(app, completionStatus);
        return;
    }
    LOG("Done submitting Score");

    /* Cleanup Controller */
    SC_ScoreController_Release(app->scoreController);

    /* Request the leaderboard here just for demonstration purposes */
    LoadLeaderboard(app, app->score, SC_SCORES_SEARCH_LIST_ALL, 15);

    /* Cleanup Score */
    SC_Score_Release(app->score);
}

static void LoadLeaderboard(AppData_t *app, SC_Score_h score, SC_ScoresSearchList_t searchList, unsigned int count)
{
    /* Create a ScoresController */
    SC_Error_t rc = SC_Client_CreateScoresController(app->client, &app->scoresController, LoadLeaderboardCompletionCallback, app);
    if (rc != SC_OK) {
        HandleError(app, rc);
        return;
    }

    /* Configure the Controller */
    SC_ScoresController_SetMode(app->scoresController, SC_Score_GetMode(score));
    rc = SC_ScoresController_SetSearchList(app->scoresController, searchList);
    if (rc != SC_OK) {
        SC_ScoresController_Release(app->scoresController); /* Cleanup Controller */
        HandleError(app, rc);
        return;
    }

    /* Load the Leaderboard for the given score and count */
    rc = SC_ScoresController_LoadScoresAroundScore(app->scoresController, score, count);
    if (rc != SC_OK) {
        SC_ScoresController_Release(app->scoresController); /* Cleanup Controller */
        HandleError(app, rc);
        return;
    }
    LOG("Loading Leaderboard...");
}

static void LoadLeaderboardCompletionCallback(void *userData, SC_Error_t completionStatus)
{
    /* Get the application from userData argument */
    AppData_t *app = (AppData_t *) userData;

    /* Check completion status */
    if (completionStatus != SC_OK) {
        SC_ScoresController_Release(app->scoresController); /* Cleanup Controller */
        HandleError(app, completionStatus);
        return;
    }

    /* Just log the scores here for demonstration purposes */
    SC_ScoreList_h scoreList = SC_ScoresController_GetScores(app->scoresController);
    if (scoreList == NULL) {
        SC_ScoresController_Release(app->scoresController); /* Cleanup Controller */
        HandleError(app, SC_NOT_FOUND);
        return;
    }
    LOG("Done loading Leaderboard");

    /* Get the score formatter here - remember that you need to add a
     * scoreloop/SLScoreFormatter.strings file to your asset files in order to retrieve a formatter.
     */
    SC_ScoreFormatter_h scoreFormatter = SC_Client_GetScoreFormatter(app->client);
    if (!scoreFormatter) {
        SC_ScoresController_Release(app->scoresController); /* Cleanup Controller */
        HandleError(app, SC_NOT_FOUND);
        return;
    }

    unsigned int i, numScores = SC_ScoreList_GetCount(scoreList);
    for (i = 0; i < numScores; ++i) {
        SC_Score_h score = SC_ScoreList_GetAt(scoreList, i);
        SC_User_h user = SC_Score_GetUser(score);
        SC_String_h login = user ? SC_User_GetLogin(user) : NULL;
        SC_String_h formattedScore;

        /* Format the score - we take ownership of string */
        int rc = SC_ScoreFormatter_FormatScore(scoreFormatter, score, SC_SCORE_FORMAT_DEFAULT, &formattedScore);
        if (rc != SC_OK) {
            HandleError(app, rc);
            return;
        }
        LOG("  Rank: %d, Result: %s, User: %s", SC_Score_GetRank(score), SC_String_GetData(formattedScore),
                login ? SC_String_GetData(login) : "<unknown>");

        /* Release the string */
        SC_String_Release(formattedScore);
    }

    /* Cleanup Controller */
    SC_ScoresController_Release(app->scoresController);
    LOG("Done Leaderboard Callback Completed");
    /* Set an Award as achieved here just for demonstration purposes */
    //AchieveAward(app, AN_AWARD_ID);
}

static void AchieveAward(AppData_t *app, const char *awardIdentifier)
{
    SC_Bool_t achieved;

    /* Create an Achievements Controller */
    SC_Error_t rc = SC_Client_CreateLocalAchievementsController(app->client, &app->achievementsController, AchieveAwardCompletionCallback, app);
    if (rc != SC_OK) {
        HandleError(app, rc);
        return;
    }

    /* Set the award with the given identifier to be achieved */
    rc = SC_LocalAchievementsController_SetAchievedValueForAwardIdentifier(app->achievementsController, awardIdentifier, &achieved);
    if (rc != SC_OK) {
        SC_LocalAchievementsController_Release(app->achievementsController); /* Cleanup Controller */
        HandleError(app, rc);
        return;
    }

    /* Synchronize achievement if indicated - this can be done at some other point in time and does not have to come
     * after every setting of an achievement.
     */
    if (SC_LocalAchievementsController_ShouldSynchronize(app->achievementsController) == SC_TRUE) {
        rc = SC_LocalAchievementsController_Synchronize(app->achievementsController);
        if (rc != SC_OK) {
            SC_LocalAchievementsController_Release(app->achievementsController); /* Cleanup Controller */
            HandleError(app, rc);
            return;
        }
        LOG("Synchronizing Achievements...");
    }
    else {
        /* Cleanup Controller */
        SC_LocalAchievementsController_Release(app->achievementsController);

        /* Load Achievement here just for demonstration purposes */
        LoadAchievements(app);
    }
}

static void AchieveAwardCompletionCallback(void *userData, SC_Error_t completionStatus)
{
    /* Get the application from userData argument */
    AppData_t *app = (AppData_t *) userData;

    /* Check completion status */
    if (completionStatus != SC_OK) {
        SC_LocalAchievementsController_Release(app->achievementsController); /* Cleanup Controller */
        HandleError(app, completionStatus);
        return;
    }
    LOG("Done synchronizing Achievements");

    /* Cleanup Controller */
    SC_LocalAchievementsController_Release(app->achievementsController);

    /* Load Achievement here just for demonstration purposes */
    LoadAchievements(app);
}

static void LoadAchievements(AppData_t *app)
{
    /* Create an Achievements Controller */
    SC_Error_t rc = SC_Client_CreateLocalAchievementsController(app->client, &app->achievementsController, LoadAchievementsCompletionCallback, app);
    if (rc != SC_OK) {
        HandleError(app, rc);
        return;
    }

    /* Load the achievements */
    LOG("Loading Achievements...");
    LoadAchievementsCompletionCallback(app, SC_OK);
}

static void LoadAchievementsCompletionCallback(void *userData, SC_Error_t completionStatus)
{
    /* Get the application from userData argument */
    AppData_t *app = (AppData_t *) userData;

    /* Check completion status */
    if (completionStatus != SC_OK) {
        SC_LocalAchievementsController_Release(app->achievementsController); /* Cleanup Controller */
        HandleError(app, completionStatus);
        return;
    }

    /* Just log the achievements here for demonstration purposes */
    SC_AchievementList_h achievementList = SC_LocalAchievementsController_GetAchievements(app->achievementsController);
    if (achievementList == NULL) {
        SC_LocalAchievementsController_Release(app->achievementsController); /* Cleanup Controller */
        HandleError(app, SC_NOT_FOUND);
        return;
    }
    LOG("Done loading Achievements");

    unsigned int i, numAchievements = SC_AchievementList_GetCount(achievementList);
    for (i = 0; i < numAchievements; ++i) {
        SC_Achievement_h achievement = SC_AchievementList_GetAt(achievementList, i);
        SC_Award_h award = SC_Achievement_GetAward(achievement);
        LOG("  Achieved Award: %s", SC_String_GetData(SC_Award_GetIdentifier(award)));
    }

    /* Cleanup Controller */
    SC_LocalAchievementsController_Release(app->achievementsController);

    /* Create a Challenge here for demonstration purposes only */
    SC_Money_h money = GetStake(app);
    if (money) {
        CreateChallenge(app, money, GetScoreResult(app), 0);
    }
    else {
        /* No balance, so skip this step and continue with next step for demonstration only */
        LoadChallenges(app);
    }
}

static void CreateChallenge(AppData_t *app, SC_Money_h stake, double result, unsigned int mode)
{
    SC_Error_t rc;
    SC_Challenge_h challenge;
    SC_Score_h score;

    /* Create a ChallengeController */
    rc = SC_Client_CreateChallengeController(app->client, &app->challengeController, CreateChallengeCompletionCallback, app);
    if (rc != SC_OK) {
        HandleError(app, rc);
        return;
    }

    /* Create a Challenge */
    rc = SC_Client_CreateChallenge(app->client, stake, NULL, mode, 0, &challenge);
    if (rc != SC_OK) {
        SC_ChallengeController_Release(app->challengeController); /* Cleanup Controller */
        HandleError(app, rc);
        return;
    }

    /* Assign challenge to controller */
    rc = SC_ChallengeController_SetChallenge(app->challengeController, challenge);
    SC_Challenge_Release(challenge); /* Not needed anymore, so cleanup */
    if (rc != SC_OK) {
        SC_ChallengeController_Release(app->challengeController); /* Cleanup Controller */
        HandleError(app, rc);
        return;
    }

    /* Create a Score object with given result */
    rc = SC_Client_CreateScore(app->client, &score);
    if (rc != SC_OK) {
        SC_ChallengeController_Release(app->challengeController); /* Cleanup Controller */
        HandleError(app, rc);
        return;
    }
    rc = SC_Score_SetResult(score, result);
    if (rc != SC_OK) {
        SC_ChallengeController_Release(app->challengeController); /* Cleanup Controller */
        SC_Score_Release(score); /* Cleanup Score */
        HandleError(app, rc);
        return;
    }

    /* Submit Challenge for score */
    rc = SC_ChallengeController_SubmitChallengeScore(app->challengeController, score);
    SC_Score_Release(score); /* Not needed anymore, so cleanup */
    if (rc != SC_OK) {
        SC_ChallengeController_Release(app->challengeController); /* Cleanup Controller */
        HandleError(app, rc);
        return;
    }
    LOG("Creating Challenge...");
}

static void CreateChallengeCompletionCallback(void *userData, SC_Error_t completionStatus)
{
    /* Get the application from userData argument */
    AppData_t *app = (AppData_t *) userData;

    /* Check completion status */
    if (completionStatus != SC_OK) {
        SC_ChallengeController_Release(app->challengeController); /* Cleanup Controller */
        HandleError(app, completionStatus);
        return;
    }
    LOG("Done creating Challenge");

    /* Cleanup Controller */
    SC_ChallengeController_Release(app->challengeController);

    /* Load open challenges just for demonstration purposes */
    LoadChallenges(app);
}

static void LoadChallenges(AppData_t *app)
{
    /* Create a Challenges Controller */
    SC_Error_t rc = SC_Client_CreateChallengesController(app->client, &app->challengesController, LoadChallengesCompletionCallback, app);
    if (rc != SC_OK) {
        HandleError(app, rc);
        return;
    }

    /* Load the open challenges */
    rc = SC_ChallengesController_LoadOpenChallenges(app->challengesController);
    if (rc != SC_OK) {
        SC_ChallengesController_Release(app->challengesController); /* Cleanup Controller */
        HandleError(app, rc);
        return;
    }
    LOG("Loading Challenges...");
}

static void LoadChallengesCompletionCallback(void *userData, SC_Error_t completionStatus)
{
    /* Get the application from userData argument */
    AppData_t *app = (AppData_t *) userData;
    SC_ChallengeList_h challengeList;
    int challengeCount;

    /* Check completion status */
    if (completionStatus != SC_OK) {
        SC_ChallengesController_Release(app->challengesController); /* Cleanup Controller */
        HandleError(app, completionStatus);
        return;
    }

    /* Get the list of challenges*/
    challengeList = SC_ChallengesController_GetChallenges(app->challengesController);

    /* Log number of challenges for demonstration only*/
    challengeCount = challengeList != NULL ? SC_ChallengeList_GetCount(challengeList) : 0;
    LOG("Done loading Challenges. Got: %d", challengeCount);

    /* Accept some challenge if there is one with mode 0 for demonstration purposes only */
    if (challengeCount > 0) {
        int i;
        SC_Challenge_h challenge;

        for (i = 0; i < challengeCount; ++i) {
            challenge = SC_ChallengeList_GetAt(challengeList, i);

            if (SC_Challenge_GetMode(challenge) == 0) {

                /* Found a challenge with mode 0, so go for it */
                AcceptChallenge(app, challenge);

                /* Cleanup Controller */
                SC_ChallengesController_Release(app->challengesController);

                return;
            }
        }
    }

    /* Cleanup Controller */
    SC_ChallengesController_Release(app->challengesController);

    /* Done with sample, so inform user for demonstration purposes */
    InformUser(app, "Note", "Successfully finished Scoreloop Integration Sample");
}

static void AcceptChallenge(AppData_t *app, SC_Challenge_h challenge)
{
    /* Create a ChallengeController */
    SC_Error_t rc = SC_Client_CreateChallengeController(app->client, &app->challengeController, AcceptChallengeCompletionCallback, app);
    if (rc != SC_OK) {
        HandleError(app, rc);
        return;
    }

    /* Set challenge to be accepted */
    rc = SC_ChallengeController_SetChallenge(app->challengeController, challenge);
    if (rc != SC_OK) {
        SC_ChallengeController_Release(app->challengeController); /* Cleanup Controller */
        HandleError(app, rc);
        return;
    }

    /* Inform server that we accepted that challenge */
    rc = SC_ChallengeController_AcceptChallenge(app->challengeController);
    if (rc != SC_OK) {
        SC_ChallengeController_Release(app->challengeController); /* Cleanup Controller */
        HandleError(app, rc);
        return;
    }
    LOG("Accepting Challenge...");
}

static void AcceptChallengeCompletionCallback(void *userData, SC_Error_t completionStatus)
{
    /* Get the application from userData argument */
    AppData_t *app = (AppData_t *) userData;
    SC_Challenge_h challenge;

    /* Check completion status */
    if (completionStatus != SC_OK) {
        SC_ChallengeController_Release(app->challengeController); /* Cleanup Controller */
        HandleError(app, completionStatus);
        return;
    }
    LOG("Done accepting Challenge");

    /* In your game you would now start the game play to get a score result. Here we just
     * pick a score result and submit the challenge
     */
    challenge = SC_ChallengeController_GetChallenge(app->challengeController);

    /* Cleanup Controller - In order to have challenge stay alive, bump its retain-count */
    SC_Challenge_Retain(challenge);
    SC_ChallengeController_Release(app->challengeController);

    /* Submit Challenge */
    SubmitChallenge(app, challenge, GetScoreResult(app), 0);

    /* Decrement retain count on challenge */
    SC_Challenge_Release(challenge);
}

static void SubmitChallenge(AppData_t *app, SC_Challenge_h challenge, double result, unsigned int mode)
{
    SC_Error_t rc;
    SC_Score_h score;

    /* Create a ChallengeController */
    rc = SC_Client_CreateChallengeController(app->client, &app->challengeController, SubmitChallengeCompletionCallback, app);
    if (rc != SC_OK) {
        HandleError(app, rc);
        return;
    }

    /* Set challenge to be accepted */
    rc = SC_ChallengeController_SetChallenge(app->challengeController, challenge);
    if (rc != SC_OK) {
        SC_ChallengeController_Release(app->challengeController); /* Cleanup Controller */
        HandleError(app, rc);
        return;
    }

    /* Create a Score object with given result and mode */
    rc = SC_Client_CreateScore(app->client, &score);
    if (rc != SC_OK) {
        SC_ChallengeController_Release(app->challengeController); /* Cleanup Controller */
        HandleError(app, rc);
        return;
    }
    rc = SC_Score_SetResult(score, result);
    if (rc != SC_OK) {
        SC_ChallengeController_Release(app->challengeController); /* Cleanup Controller */
        SC_Score_Release(score); /* Cleanup Score */
        HandleError(app, rc);
        return;
    }
    rc = SC_Score_SetMode(score, mode);
    if (rc != SC_OK) {
        SC_ChallengeController_Release(app->challengeController); /* Cleanup Controller */
        SC_Score_Release(score); /* Cleanup Score */
        HandleError(app, rc);
        return;
    }

    /* Submit Challenge for score */
    rc = SC_ChallengeController_SubmitChallengeScore(app->challengeController, score);
    SC_Score_Release(score); /* Not needed anymore, so cleanup */
    if (rc != SC_OK) {
        SC_ChallengeController_Release(app->challengeController); /* Cleanup Controller */
        HandleError(app, rc);
        return;
    }
    LOG("Submitting Challenge...");
}

static void SubmitChallengeCompletionCallback(void *userData, SC_Error_t completionStatus)
{
    /* Get the application from userData argument */
    AppData_t *app = (AppData_t *) userData;

    /* Check completion status */
    if (completionStatus != SC_OK) {
        SC_ChallengeController_Release(app->challengeController); /* Cleanup Controller */
        HandleError(app, completionStatus);
        return;
    }
    LOG("Done submitting Challenge");

    /* Cleanup Controller */
    SC_ChallengeController_Release(app->challengeController);

    /* Done with sample, so just inform user for demonstration purposes */
    InformUser(app, "Note", "Successfully finished Scoreloop Integration Sample");
}

static void DisplayDialog(AppData_t *app, const char* title, const char* message)
{
	/* Close a former dialog - if any */
	if (app->dialog) {
		dialog_destroy(app->dialog);
		app->dialog = 0;
	}

    /* Open a new alert dialog here - you would probably want to do something more elaborate */
    dialog_create_alert(&app->dialog);
    dialog_set_title_text(app->dialog, title);
    dialog_set_alert_message_text(app->dialog, message);
    dialog_add_button(app->dialog, DIALOG_OK_LABEL, true, NULL, true);
    dialog_show(app->dialog);
}

static void InformUser(AppData_t *app, const char* title, const char* message)
{
    /* Inform user by displaying a simple dialog here */
	DisplayDialog(app, title, message);

	/* Also log title and message */
	LOG("%s: %s", title, message);
}

static void HandleError(AppData_t *app, SC_Error_t error)
{
    /* Inform user with an alert dialog here - you would probably want to do a more intelligent error handling instead */
    InformUser(app, "Error", SC_MapErrorToStr(error));

    /* Also log the error */
    LOG("%s", SC_MapErrorToStr(error));
}

static double GetScoreResult(AppData_t *app)
{
    /* Just return a random result here */
    return (double) (random() % 1000);
}

static SC_Money_h GetStake(AppData_t *app)
{
    /* Get all possible stakes */
    SC_MoneyList_h moneyList = SC_Session_GetChallengeStakes(SC_Client_GetSession(app->client));

    /* Just pick the first stake here - if available */
    if (SC_MoneyList_GetCount(moneyList) > 0) {
        return SC_MoneyList_GetAt(moneyList, 0);
    }
    else {
        return NULL;
    }
}



